# Spike - Argparse and help screens

In the Python CLI codebase, we use the [argparse](https://docs.python.org/3/library/argparse.html) module to parse commandline arguments. This third party modules controls the types of errors and help screens we return according to the types of inputs received.

In this document, we will discuss how we can extend the argparser module for our purposes to match our intended UX. The entites that will be altered are based on the UX designs provided [here](https://ljfz3b.axshare.com/#id=yokln4&p=conjur_main_help&g=1).

### Help screen

By default, [`ArgumentParser`](https://docs.python.org/2/library/argparse.html#argparse.ArgumentParser) groups command-line arguments into “positional” and “optional” arguments when displaying help messages. When there is more appropriate grouping than the default naming, we can use the [`add_argument_group()`](https://docs.python.org/2/library/argparse.html#argparse.ArgumentParser.add_argument_group) method:

For example, instead of the following

```
positional arguments:
  {whoami,list,variable,policy}
    whoami              Provides information about the user making an API request.
...

optional arguments:
  -h, --help            show this help message and exit
  -v, --version         show program's version number and exit
...

```

We can change it to:

```
Subcommands/Commands:
  {whoami,list,variable,policy}
    whoami              Provides information about the user making an API request.
...

Global options:
  -v, --version         Show program's version number and exit
...
```

In the main parser add the following:

```
parser = MyParser(description="...",
									epilog="...",
									add_help=False)
```

For all global arguments (optional, `--version`, `--debug`, etc) we can add the following

```
globals_optionals = parser.add_argument_group("Global arguments")
globals_optionals.add_argument('-h', '--help', action='help', help="...")
.
.
.
```

For all commands (positional, `variable`, `policy`) we can do the following:

```
resource_subparsers = parser.add_subparsers(dest='resource', title="Commands")
```

For all subcommands (positional, `get` /`set`, `apply`/`replace`, `delete`) we can add the following:

```
variable_parser = resource_subparsers.add_parser('variable', help="...", add_help=False)
variable_subparsers = variable_parser.add_subparsers(dest='action', title="Subcommands")

variable_global_option = variable_parser.add_argument_group("Global arguments")
variable_global_option.add_argument('-h', '--help', action='help', help="...")
```

#### Usage

We expect that usage will change depending on command (`variable` for example) and subcommand (`get`/`set` for example). We don't want to add them as argument groups because if the populated items aren't flags, the module will assume them as required arguments. For this reason, we want to add Usage as part of the program's description.

Usage for each command can be added by creating functions for each. For example, for each entity we will add somehting like the following:

```bash
### Main screen
def main_description(name=None):
        return '''
*****************************************************************
*   Conjur’s CLI for managing roles, resources and privileges   *
*****************************************************************
Copyright © 1999-2020 CyberArk Software Ltd. All rights reserved.

Usage:
    conjur [global options] command subcommand [options] [arguments…]'''


### Variable screen
def variable_description(name=None):
        return '''
Usage:
    conjur [global options] command subcommand [arguments…]'''

```

And call them like

```bash
### Main screen
resource_subparsers = parser.add_subparsers(dest='resource', title="Commands")

### Variable screen
variable_parser = resource_subparsers.add_parser('variable', des=variable_description)
```

We can remove the autogenerated usage leftovers by adding `usage=argparse.SUPPRESS` to the inital parser  and all subparsers for each command declaration.

```bash
parser = MyParser(..., usage=argparse.SUPPRESS)
```

### Order

The order of argument groups (Global arguments, Commands/Subcommands) is effected the order at which they are declared. Global should be before Commands and Subcommands. 

### Title

We will have a separate function that will act as the formatter for how the CLI description should look like. For example:

```bash
def main_description(name=None):
	return '''
*****************************************************************
*   Conjur’s CLI for managing roles, resources and privileges   *
*****************************************************************
Copyright © 1999-2020 CyberArk Software Ltd. All rights reserved.

Usage:
    conjur [global options] command subcommand [options] [arguments…]'''
```

The main parser will have `formatter_class=argparse.RawTextHelpFormatter` to allow us to maintain the whitespaces for our help text.  This will resemble something like:

```bash
parser = MyParser(.... formatter_class=argparse.RawTextHelpFormatter)
```

### Examples

The UX design page requires that examples are provided. Because non-flagged arguments are deemed as required parameters, it might be best to make the example as part of each description at the top and below Usage. 

```
Example:
    conjur variable get secrets/mysecret supersecret
		conjur variable set secret/mysecret supersecret

```

If we attempt to create a new argument group and add arguments like the following we will get an error

```
example_resource = parser.add_argument_group("Example")
example_resource.add_argument('My example')
```

I will get the following when I run `./pkg_bin/conjur-cli --helpds`

```
Error the following arguments are required: My example
```